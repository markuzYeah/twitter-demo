/*
 *
 * underscore mixins
 *
 */
;(function(undefined){
  "use strict";
  //
  // checking wheather on node or browser, and attaching the global obj into
  // var ROOT
  var crypto = require('crypto')
  , _ = require('lodash')
  ;
  //
  // utilities
  var utils = (function(){
    var print = function(){
      console.log.apply(this, arguments)
    }
    //
    // an alias for process.stdout.write for node, and fallback to
    // console.log on the browser.
    var put = function(){
      var msg
      arguments.length ? msg = _.flatten(arguments).join(' ') : msg = ''
      exports ? process.stdout.write(msg) : console.log(msg)
    }
    //
    // an alias to process.exit for node, and a fallback to throw an fake
    // error on the browser
    var exit = function(){
      var msg = 'No actual error, just exiting... :)'  
      exports ? process.exit() : function(){throw new Error(msg)}()
    }
    //
    // method to kill a function and displaing a given message. It throws
    // a fake error on the browser and on node.
    var kill = function(){
      var msg
      arguments.length ? msg = _.flatten(arguments) : msg = ['']
      //
      // msg is an array, this why it looks weird!
      console.log.apply(console.log, msg)
      throw new Error('No actual error, just killed process... :)\n\n');
    }
    //
    // an alias to setTimeout, because it has a *weird* interface.
    var delay = function(ms, callBack){
      setTimeout(function(){
        callBack()
      }, ms);
    }
    //
    // an alias to setInterval, because it has a *weird* interface.
    var repeat = function(ms, callBack){
      setInterval(function(){
        callBack();
      }, ms);
    }
    //
    // returns a random number between 0 and n.
    var randNum = function(num){
      return Math.floor((num + 1)*Math.random());
    }
    //
    // a random id/num generated by the crypto module (stronger)
    var randId = function(len, base, str) {
      len = len || 1
      str = str || ''
      base = base || 'base64'
      var buf = crypto.randomBytes(len)
      //
      if (base === 'dec') {
        var old_base = 'dec'
        base = 'hex'
        len = len || 16
      }
      //
      if (len > 16) len = 16
      //
      str =str + buf.toString(base).replace(/\//g, '').
                                    replace(/\=/g, '').replace(/\+/g, '')
      //
      if (old_base === 'dec') str = parseInt(str, 16).toString()
      //
      if (str.length < len) {
        return randId(len, base, str)
      } else {
        if (old_base === 'dec') {
          str = str.split('').slice(0, len).join('').replace(/\./g, '').
                replace(/e/g, '').replace(/\+/g, '').split('')
          //
          if (str.length < len) return randId(len, base, str)
          if (str.length > len) {
            str = str.split('').slice(0, len).join('')
          }
          return parseInt(str.join(''))
        } else {
          str = str.split('').slice(0, len).join('').
            replace(/\./g, '').replace(/e/g, '').replace(/\+/g, '')
          //
          if (str.length < len) return randId(len, base, str)
          if (str.length > len) {
            str = str.split('').slice(0, len).join('')
          }
          return str;
        }
      }
    };
    //
    // given a date format, parse it into epoch time.
    var toEpoch = function(date) {
      if (date === undefined){
        date = new Date()
      }
      else{
        date = new Date(date)
      }
      //
      y = date.getFullYear()
      m = date.getMonth()
      d = date.getDate()
      h = date.getHours()
      min = date.getMinutes()
      sec = date.getSeconds()
      ms = date.getMilliseconds()
      //
      return parseInt(Date.UTC(y, m, d, min, sec, ms))
    }
    //
    // deep extend. Better then just prototyping :)
    //
    var deepExtend = function deepExtend(obj) {
      var parentRE = /#{\s*?_\s*?}/
      , slice = Array.prototype.slice
      , hasOwnProperty = Object.prototype.hasOwnProperty
      
      _.each(slice.call(arguments, 1), function(source) {
        for (var prop in source) {
          if (hasOwnProperty.call(source, prop)) {
            if (_.isUndefined(obj[prop])) {
              obj[prop] = source[prop];
            }
            else if (_.isString(source[prop]) && parentRE.test(source[prop])) {
              if (_.isString(obj[prop])) {
                obj[prop] = source[prop].replace(parentRE, obj[prop]);
              }
            }
            else if (_.isArray(obj[prop]) || _.isArray(source[prop])){
              if (!_.isArray(obj[prop]) || !_.isArray(source[prop])){
                throw 'Error: Trying to combine an array with a non-array (' + prop + ')';
              } else {
                obj[prop] = _.reject(_.deepExtend(obj[prop], source[prop]), function (item) { return _.isNull(item);});
              }
            }
            else if (_.isObject(obj[prop]) || _.isObject(source[prop])){
              if (!_.isObject(obj[prop]) || !_.isObject(source[prop])){
                throw 'Error: Trying to combine an object with a non-object (' + prop + ')';
              } else {
                obj[prop] = deepExtend(obj[prop], source[prop]);
              }
            } else {
              obj[prop] = source[prop];
            }
          }
        }
      });
      return obj;
    };
    //
    //
    //
    return {
      print: print
    , put: put
    , exit: exit
    , kill: kill
    , delay: delay
    , repeat: repeat
    , randId: randId
    , randNum: randNum
    , toEpoch: toEpoch
    , deepExtend: deepExtend
    }
  })();
  //
  var E = function(){} //just a name space

  //rather not do the prototype trick
  _.map(utils, function(method, name){ E[name] = method });
  //
  _.mixin({e: E});

  module.exports = _;
}).apply(this);
